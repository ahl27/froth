[{"path":"http://www.ahl27.com/froth/articles/ArithmeticAndStacks.html","id":"more-arithmetic","dir":"Articles","previous_headings":"","what":"More Arithmetic","title":"Arithmetic and Stacks","text":"last section, learned basic arithmetic using + *. However, froth incorporates host arithmetic expressions. Eagle-eyed readers may spotted ’ve working commutative operations, meaning order doesn’t matter (+b = b+). happens use non-commutative expressions, division exponentiation? froth executes words, always treats top stack last argument expression. means , something like b /, b top stack result / b. froth uses R mathematical operations, don’t worry things like converting integers doubles, double vs. single length numbers. following mathematical operations built froth: / ( b -- n ): division (5 2 / => 2.5) %/% ( b -- n): integer division (5 2 %/% => 2) mod ( b -- rem ): remainder dividing / b /mod ( b -- rem quot ): integer divides %/% b, pushes remainder quotient ^ ( b -- n ): raises ^b negate ( -- n ): negates abs ( -- n ): takes absolute value min ( b -- min ): pushes min(,b) max ( b -- max ): pushes max(,b) sqrt ( -- root ): pushes sqrt()","code":""},{"path":"http://www.ahl27.com/froth/articles/ArithmeticAndStacks.html","id":"stack-operators","dir":"Articles","previous_headings":"","what":"Stack Operators","title":"Arithmetic and Stacks","text":"Unfortunately, problems just can’t solved stacks postfix…least, without tools. Consider equation (-b)/c. postfix, b - c /. Now, wanted write word definition ( c b -- d ) applies function (-b)/c, ’d find isn’t quite possible tools . Defining : SOLUTION? - / instead apply c / (- b), isn’t quite right. need way swap top two values, run (-b)/c. stack operators come handy. operator ’re looking aptly named SWAP ( b -- b ). swaps first two elements stack. Using , can write definition: (2-1)/4 = 1/4 = 0.25, works! couple stack operators often useful: SWAP ( b -- b ): swap top two stack elements DUP ( n -- n n ): duplicate top stack element ( b -- b ): duplicate second element top stack ROT ( b c -- b c ): rotate third item top DROP ( n -- ): discard top element stack .S ( -- ): print contents stack also set stack operators work pairs numbers, perform functions: 2SWAP ( b c d -- c d b ): swap top two pairs 2DUP ( b -- b b ): duplicate top pair 2OVER ( p1 p2 -- p1 p2 p1 ): duplicate second pair (p1) top 2DROP ( b -- ): discard top pair","code":"fr> : TRYTHIS ( c a b -- d ) - swap / ; ok. fr> 4 2 1 trythis . 0.25 ok."},{"path":"http://www.ahl27.com/froth/articles/ArithmeticAndStacks.html","id":"two-stacks","dir":"Articles","previous_headings":"","what":"Two stacks?","title":"Arithmetic and Stacks","text":"froth actually two stacks. main one, parameter stack, ’ll spend majority time working . Whenever “push stack”, ’s referring parameter stack. However, froth also second stack called Return Stack. ’s possible use stack sort “temporary space” hold values process things. ’s important ensure clear values temporary stack finish processing! froth much forgiving Forth point, ’s good get practice good Forth code. >R ( n -- ): moves value parameter stack return stack R> ( -- n ): moves value return stack parameter stack R@ ( -- n ): copies value return stack parameter stack can sometimes useful. instance, say wanted swap second third elements stack (, go 2 3 1 3 2 1). can : Fundamental Forth gives excellent example using operators: suppose want write function quadratic ( b c x -- n ) returns ax^2 + bx + c.","code":"fr> 2 3 1 ok. fr> >R SWAP R> ok. fr> .s [[1]] [1] 1  [[2]] [1] 2  [[3]] [1] 3  [[4]] NULL  ok. fr> : QUADRATIC ( a b c x -- n ) >r swap rot r@ * + r> * + ;  ok. fr> 2 7 9 3 quadratic . 48 ok."},{"path":"http://www.ahl27.com/froth/articles/ArithmeticAndStacks.html","id":"other-miscellaneous-operators","dir":"Articles","previous_headings":"","what":"Other Miscellaneous operators","title":"Arithmetic and Stacks","text":"completeness, arithmetic operations: - 1+ ( n1 -- n2 ): adds 1 - 1- ( n1 -- n2 ): subtracts 1 - 2+ ( n1 -- n2 ): adds 2 - 2- ( n1 -- n2 ): subtracts 2 - 2* ( n1 -- n2 ): multiplies 2 - 2/ ( n1 -- n2 ): divides 2 also funky double operators: - */ ( b c -- n ): pushes (*b) / c - */mod ( b c -- rem quot ): pushes remainder quotient (*b) %/% c","code":""},{"path":"http://www.ahl27.com/froth/articles/ArithmeticAndStacks.html","id":"words-in-this-chapter","dir":"Articles","previous_headings":"","what":"Words in this chapter","title":"Arithmetic and Stacks","text":"/ ( b -- n ): division (5 2 / => 2.5) %/% ( b -- n): integer division (5 2 %/% => 2) mod ( b -- rem ): remainder dividing / b /mod ( b -- rem quot ): integer divides %/% b, pushes remainder quotient ^ ( b -- n ): raises ^b negate ( -- n ): negates abs ( -- n ): takes absolute value min ( b -- min ): pushes min(,b) max ( b -- max ): pushes max(,b) sqrt ( -- root ): pushes sqrt() SWAP ( b -- b ): swap top two stack elements DUP ( n -- n n ): duplicate top stack element ( b -- b ): duplicate second element top stack ROT ( b c -- b c ): rotate third item top DROP ( n -- ): discard top element stack .S ( -- ): print contents stack 2SWAP ( b c d -- c d b ): swap top two pairs 2DUP ( b -- b b ): duplicate top pair 2OVER ( p1 p2 -- p1 p2 p1 ): duplicate second pair (p1) top 2DROP ( b -- ): discard top pair >R ( n -- ): moves value parameter stack return stack R> ( -- n ): moves value return stack parameter stack R@ ( -- n ): copies value return stack parameter stack 1+ ( n1 -- n2 ): adds 1 1- ( n1 -- n2 ): subtracts 1 2+ ( n1 -- n2 ): adds 2 2- ( n1 -- n2 ): subtracts 2 2* ( n1 -- n2 ): multiplies 2 2/ ( n1 -- n2 ): divides 2 */ ( b c -- n ): pushes (*b) / c */mod ( b c -- rem quot ): pushes remainder quotient (*b) %/% c","code":""},{"path":"http://www.ahl27.com/froth/articles/Conditionals.html","id":"logical-operators","dir":"Articles","previous_headings":"","what":"Logical Operators","title":"Conditionals and Branching","text":"Just like programming languages, froth supports number logical operators. : push TRUE top two elements TRUE : push TRUE least one top two elements TRUE XOR: push TRUE exactly one top two elements TRUE : push TRUE top element FALSE vice-versa words come built-checks. example, ?DUP duplicates top value zero. error-handling, can use ABORT\". ABORT\" checks stack value; TRUE, clears stacks prints error message.","code":""},{"path":"http://www.ahl27.com/froth/articles/Conditionals.html","id":"words-in-this-chapter","dir":"Articles","previous_headings":"","what":"Words in this chapter","title":"Conditionals and Branching","text":": top stack TRUE, executes. Else jumps next else block. else: executes commands preceding execute. : terminates ...else block. \\: signals interpreter ’re making newline without running commands =: top two elements equal? <: top element greater first? >: top element less first? <>: top two elements equal? 0=: top element zero? 0<: top element greater zero? 0>: top element less zero? <=: top element greater equal second? >=: top element less equal second? : push TRUE top two elements TRUE : push TRUE least one top two elements TRUE XOR: push TRUE exactly one top two elements TRUE : push TRUE top element FALSE vice-versa ?DUP: duplicate top value nonzero ABORT\": abort top value true, print error message (terminated \")","code":""},{"path":"http://www.ahl27.com/froth/articles/FundamentalFroth.html","id":"the-dictionary","dir":"Articles","previous_headings":"","what":"The Dictionary","title":"Fundamental Froth","text":"dictionary FORTH list words defined sequentially. froth initializes words first loads, user-defined words added sequentially . input line text, froth splits command spaces searches word dictionary. finds word, executes related code. , returns error message. means must separate command space! example: froth couldn’t understand command, responded :star ?. :star isn’t defined word–order make definition work, space-separate colon words. Emitting values character character gets old pretty fast. can use words .\" \" print whole strings: Note space separation .\" string. ending \" part string, doesn’t need space separated. froth also special words. encountered one input 45–put number 45 onto stack. froth can’t find word dictionary, checks see ’ve input number. , executes special command puts onto stack. can redefine word time just writing new definition . froth always use recent definition word ’ve given , remembers old ones. wanted go back previous definition, can use FORGET word. define add_two twice–first defines adding two number, second adding four. call forget add_two, reverts first definition. Calling second time removes definition entirely. ’re curious words defined, can list using WORDS words.","code":"fr> :star 42 emit ; :star ? fr> : star 42 emit ; ok. fr> star *ok. fr> .\" Hello, world!\" Hello, world! ok. fr> : add_two 2 + ;  ok. fr> : add_two 2 2 + + ; ok. fr> 5 add_two . 9 ok. fr> forget add_two ok. fr> 5 add_two 7 ok. fr> forget add_two ok. fr> 5 add_two add_two ?"},{"path":"http://www.ahl27.com/froth/articles/FundamentalFroth.html","id":"the-data-stack","dir":"Articles","previous_headings":"","what":"The Data Stack","title":"Fundamental Froth","text":"’ve talking lot stack, …? ’re unfamiliar stack data structure, concept essentially tower bricks. time “add” stack, place brick top tower. time remove stack, take brick top, otherwise entire stack fall apart! means recently added brick always first one remove. concept typically referred “Last , First ” (LIFO). talk stacks, use word “push” refer adding item stack, “pop” refer taking item stack. Let’s showcase example. ’re going use new word called .. period takes first element stack tells (pops item). Note last element added (3) first element got back. LIFO action. Stacks lend well style expression notation called reverse Polish notation (RPN), also called postfix notation. people used infix notation, operators found operands. means wanted add two numbers b, ’d write + b. Postfix notation instead puts operator operands, meaning ’d write sum b b +. may feel unintuitive, number benefits. First, postfix notation need parentheses order operations; operations define order applied. example: works especially well froth, since stack already! write operation postfix notation, ’ll get result. Let’s try simple arithmetic: Walking expressions: 1 2 + => 1 + 2 + 3 2 3 4 + * => 2 * (3+4) = 2*7 = 14 2 3 * 4 5 * + => (2*3) + (4*5) = 6 + 20 = 26 actually going hood? Let’s walk 1 2 + pop_result: froth reads 1, pushes 1 onto stack. froth reads 2, pushes 2 onto stack. froth reads +. + pops two items stack (2, 1). + adds two items just popped (1 + 2). + pushes result operation (3) back onto stack. froth reads pop_result, looks definition (. cr). pop_result first calls ., pops first element stack (3). pop_result calls cr, prints new line. froth sees commands, acknowledges ok. nice thing postfix operators can implicitly act whatever stack. example, ’s relatively easy define word doubles whatever stack: Wait second–doesn’t * pop two values return? ’ve defined single value, 2! construction design. * pops whatever top two values stack , multiplies , pushes result. means , since ’re pushing single value double, function multiply whatever top stack two return .","code":"fr> 1 ok. fr> 2 ok. fr> 3 ok. fr> . . . 3 2 1 ok. (infix) a * (b+c) = a b c + * (postfix) (infix) (a*b) + (c*d) = a b * c d * + (postfix) fr> : pop_result . cr ; fr> 1 2 + pop_result 3  ok. fr> 2 3 4 + * pop_result 14 ok. fr> 2 3 * 4 5 * + pop_result 26 fr> : double 2 * ; ok. fr> 1 ok. fr> double double double double . 16 ok."},{"path":"http://www.ahl27.com/froth/articles/FundamentalFroth.html","id":"watch-out-for-the-stack","dir":"Articles","previous_headings":"","what":"Watch out for the stack!","title":"Fundamental Froth","text":"’s important note major concern style architecture. Let’s return definition double: mentioned allows us arbitrarily double whatever top stack. However, happens ’s nothing top stack? Let’s use clear word remove elements stack, run double: called stack underflow error, kills froth session. can reinitialize froth() (preserve defined words), ’s important exercise caution dealing stack. Make sure ’re aware state words expect state leave stack ! Conventional Forth communicates adding comments words. Comments added using ( ) words, typically form ( before_state -- after_state ) (note space separation parentheses; ’re also words!). example: case, DOUBLE expects find single number n1 stack, replaces n2. essence, expect find least one value, end one value. Another example: SUM equivalent + operation. + expects find least two elements stack (,b), replaces res. Operations don’t replace. notation emit simply : emit ( n -- ), since pops element stack doesn’t replace .","code":"fr> : double 2 * ; ok. fr> clear ok. fr> double Error: stack is empty. > fr> : DOUBLE ( n1 -- n2 ) 2 * ; ok. fr> : SUM ( a b -- res ) + ; ok."},{"path":"http://www.ahl27.com/froth/articles/FundamentalFroth.html","id":"when-all-goes-wrong","dir":"Articles","previous_headings":"","what":"When all goes wrong","title":"Fundamental Froth","text":"find real pickle, RESET word completely reset froth environment first initialized. can also use CTRL+C kill running processes, CLEAR delete contents stack.","code":""},{"path":"http://www.ahl27.com/froth/articles/FundamentalFroth.html","id":"words-in-this-chapter","dir":"Articles","previous_headings":"","what":"Words in this chapter","title":"Fundamental Froth","text":"<NUMBER> ( -- n ) : pushes number onto stack emit ( n -- ) : prints top number stack, interpreting ASCII cr ( -- ): prints new line .\" xxx\" ( -- ): prints xxx terminal. Note \" terminates string. : xxx yyy ; ( -- ) : defines word xxx comprised words yyy + (b -- n): adds +b * (b -- n): multiplies *b . (n -- ): pops top element stack prints clear ( x1 x2 ... -- ): removes elements stack reset ( -- ): reset froth defaults (wipe user definitions, reinitialize built-definitions, reset stacks)","code":""},{"path":"http://www.ahl27.com/froth/articles/Glossary.html","id":"glossary-of-words","dir":"Articles","previous_headings":"","what":"Glossary of Words","title":"glossary","text":"can list installed words froth WORDS word, use froth.dictionary() R. following words referenced previous chapters. <NUMBER> ( -- n ) : pushes number onto stack emit ( n -- ) : prints top number stack, interpreting ASCII cr ( -- ): prints new line .\" xxx\" ( -- ): prints xxx terminal. Note \" terminates string. : xxx yyy ; ( -- ) : defines word xxx comprised words yyy + (b -- n): adds +b * (b -- n): multiplies *b . (n -- ): pops top element stack prints clear ( x1 x2 ... -- ): removes elements stack reset ( -- ): reset froth defaults (wipe user definitions, reinitialize built-definitions, reset stacks) / ( b -- n ): division (5 2 / => 2.5) %/% ( b -- n): integer division (5 2 %/% => 2) mod ( b -- rem ): remainder dividing / b /mod ( b -- rem quot ): integer divides %/% b, pushes remainder quotient ^ ( b -- n ): raises ^b negate ( -- n ): negates abs ( -- n ): takes absolute value min ( b -- min ): pushes min(,b) max ( b -- max ): pushes max(,b) sqrt ( -- root ): pushes sqrt() SWAP ( b -- b ): swap top two stack elements DUP ( n -- n n ): duplicate top stack element ( b -- b ): duplicate second element top stack ROT ( b c -- b c ): rotate third item top DROP ( n -- ): discard top element stack .S ( -- ): print contents stack 2SWAP ( b c d -- c d b ): swap top two pairs 2DUP ( b -- b b ): duplicate top pair 2OVER ( p1 p2 -- p1 p2 p1 ): duplicate second pair (p1) top 2DROP ( b -- ): discard top pair >R ( n -- ): moves value parameter stack return stack R> ( -- n ): moves value return stack parameter stack R@ ( -- n ): copies value return stack parameter stack 1+ ( n1 -- n2 ): adds 1 1- ( n1 -- n2 ): subtracts 1 2+ ( n1 -- n2 ): adds 2 2- ( n1 -- n2 ): subtracts 2 2* ( n1 -- n2 ): multiplies 2 2/ ( n1 -- n2 ): divides 2 */ ( b c -- n ): pushes (*b) / c */mod ( b c -- rem quot ): pushes remainder quotient (*b) %/% c : top stack TRUE, executes. Else jumps next else block. else: executes commands preceding execute. : terminates ...else block. \\: signals interpreter ’re making newline without running commands =: top two elements equal? <: top element greater first? >: top element less first? <>: top two elements equal? 0=: top element zero? 0<: top element greater zero? 0>: top element less zero? <=: top element greater equal second? >=: top element less equal second? : push TRUE top two elements TRUE : push TRUE least one top two elements TRUE XOR: push TRUE exactly one top two elements TRUE : push TRUE top element FALSE vice-versa ?DUP: duplicate top value nonzero ABORT\": abort top value true, print error message (terminated \") ( end start -- ): starts definite loop start end LOOP ( -- ): increments loop counter 1 +LOOP ( n -- ): increments loop counter n ( -- n ): copies current loop counter stack J ( -- n ): copies enclosing loop’s counter stack K ( -- n ): copies enclosing loop’s enclosing loop’s counter stack BEGIN ( -- ): starts indefinite loop ( -- ): returns BEGIN ( flag -- ): flag, continue; else jump REPEAT REPEAT ( -- ): returns BEGIN following LEAVE ( -- ): leave current loop immediately VARIABLE xxx: creates variable named xxx ! ( n addr -- ): stores value n address addr @ ( addr -- n ): copies value addr stack ? ( addr -- ): prints value addr +! ( n addr -- ): adds value n value addr CONSTANT xxx (n -- ): creates constant called xxx stores n; xxx returns n called ALLOT ( addr ncells -- ): allocates ncells cells addr CREATE xxx y1 , y2 , ... yn ,: creates array xxx values y1, y2, ... yn CELLS ( n -- ): creates memory address offset arrays FILL ( addr ncells val -- ): fills ncells cells memory beginning addr val ERASE ( addr ncells -- ): fills ncells cells memory beginning addr 0 REALLOT ( addr ncells -- ): reallots array addr size ncells. EXTEND ( addr ncells -- ): extends array addr ncells cells LENGTH ( addr -- len ): pushes length array addr onto stack LENGTH? ( addr -- ): prints length array addr","code":""},{"path":"http://www.ahl27.com/froth/articles/Loops.html","id":"definite-loops","dir":"Articles","previous_headings":"","what":"Definite loops","title":"Loops","text":"Definite loops ones specify exactly many times certain process happen. Just like Forth, specify loops ...LOOP. Let’s look example: types loops five main components: END START xxx LOOP. END START specify ending starting values loop counter. Think like counting: start START begin counting END. every number count, stuff LOOP. case, ’ve defined loop 5 0 ... LOOP. means ’ll start 0 count 5. value (0, 1, 2, 3, 4), middle stuff, case printing Hello!. Note stop END without stuff . ’s often useful able stuff number ’re currently . instance, wanted print number ’re currently counting saying Hello!? case, use special word , copies current value loop counter stack. LOOP command tells froth add 1 loop counter. means can use negative numbers /fractions loop limits: Like examples Chapter 1, can make words expect find elements stack input loop:","code":"fr> 5 0 DO .\" Hello!\" CR LOOP Hello! Hello! Hello! Hello! Hello!  ok. fr> 5 0 DO I . .\" Hello!\" CR LOOP 0 Hello!  1 Hello!  2 Hello!  3 Hello!  4 Hello!  ok. fr> 0 -2 DO .\" looping!\" LOOP looping! looping! ok. fr> 3.5 0.5 DO .\" fraction!\" LOOP fraction! fraction! fraction! ok. fr> : MULTIPLICATION ( n -- ) cr 11 1 do dup i * . loop drop ; ok. fr> 7 multiplication 7 14 21 28 35 42 49 56 63 70 ok."},{"path":"http://www.ahl27.com/froth/articles/Loops.html","id":"more-complex-loops","dir":"Articles","previous_headings":"","what":"More Complex Loops","title":"Loops","text":"...statements can nested within loops make computer certain operations certain loop iterations. example: loop proceeds 0 64. loop counter equivalent multiple 8 (8 mod 0= ), prints newline. Either way, prints star. Just like ...statements, can also nest loops. example: produces (small) multiplication table. change loop limits, can change big table . built-words copies current loop counter stack. wanted nested loops wanted access outer loop counter inner loop, J copies value stack. K performs similar operation, returns loop counter two levels . example: three nested loops. outermost one executes twice, counting 0 2. middle loop executes twice per outer loop, counting 2 4 time. inner loop executes twice per middle loop, counting 4 6 time. , outer loop runs twice, middle loop 4 times, inner loop 8 times. innermost loop, use get loop counter, j get second loop counter, K get outermost loop counter. also don’t always increment loop value 1. Instead, can use +LOOP word, expects value stack increments loop counter amount. example, can modify previous triple loop: Now outermost loop iterates 0 10 5 (10 0 ... 5 +LOOP), second loop iterates 0 4 2 (4 0 ... 2 +LOOP), innermost loop iterates 2 0 -1 (0 2 ... -1 +LOOP). see ’s changed? ’s one key difference outer two loops inner loop previous example. outer loops iterate long ’re less end value, inner loop iterates long greater equal end value. use loop negative +LOOP value, keep mind loop iterate additional time compared positive direction. example, 5 0 ... 1 +LOOP iterates 5 times, whereas 0 5 ... -1 +LOOP iterates 6 times.","code":"fr> 64 0 do i 8 mod 0= if cr then .\" *\" loop * * * * * * * *  * * * * * * * *  * * * * * * * *  * * * * * * * *  * * * * * * * *  * * * * * * * *  * * * * * * * *  * * * * * * * * ok. fr> : multip ( n -- ) cr 5 1 do dup i * . loop drop ; ok. fr> : table ( -- ) cr 5 1 do i multip loop ; 1 2 3 4  2 4 6 8  3 6 9 12  4 8 12 16 ok. fr> 2 0 DO 2 0 DO 2 0 DO I J K . . . CR LOOP LOOP LOOP 0 0 0  0 0 1  0 1 0  0 1 1  1 0 0  1 0 1  1 1 0  1 1 1  ok. fr> 10 0 DO 4 0 DO 0 2 DO I J K . . . CR -1 +LOOP 2 +LOOP 5 +LOOP 0 0 2  0 0 1  0 0 0  0 2 2  0 2 1  0 2 0  5 0 2  5 0 1  5 0 0  5 2 2  5 2 1  5 2 0  ok."},{"path":"http://www.ahl27.com/froth/articles/Loops.html","id":"indefinite-loops","dir":"Articles","previous_headings":"","what":"Indefinite Loops","title":"Loops","text":"Indefinite loops keep going without specified end point. loops use BEGIN...rather ...LOOP. basic syntax , except check stack TRUE. finds TRUE, loop terminates, otherwise execution jumps back BEGIN. start 0, iteration loop add 1 . duplicate twice, print one copies, let check second copy greater 10. value becomes 11, 10 > evaluates TRUE loop exits. checks condition end loop, wanted check beginning? BEGIN...loops always execute least , sometimes ’s preferable loop doesn’t always execute. , BEGIN......REPEAT loops. examines stack similar , skips immediately REPEAT condition TRUE. Let’s try previous example , using loop instead: differences . First, ’ve reverse comparison sign. loop continues condition true, whereas BEGIN...goes loop true. particular cases, need loop never ends. BEGIN...loop run forever without terminating. ’d include example, never stop running… absence , ’ll showcase use BEGIN...alongside another operator, LEAVE. LEAVE exits current loop immediately. example: Normally BEGIN...loop go forever. However, middle ’re 10 > leave . compares current value stack 10, ’s greater 10, run leave. soon value stack reaches 11, execute leave loop finishes.","code":"fr> 0 BEGIN 1 + dup dup . 10 > UNTIL 1 2 3 4 5 6 7 8 9 10 11 ok. fr> 0 BEGIN dup 10 < WHILE dup . 1 +  REPEAT 0 1 2 3 4 5 6 7 8 9 ok. fr> 0 begin 1 + dup dup . 10 > if leave then again 1 2 3 4 5 6 7 8 9 10 11 ok."},{"path":"http://www.ahl27.com/froth/articles/Loops.html","id":"words-in-this-chapter","dir":"Articles","previous_headings":"","what":"Words in this chapter","title":"Loops","text":"( end start -- ): starts definite loop start end LOOP ( -- ): increments loop counter 1 +LOOP ( n -- ): increments loop counter n ( -- n ): copies current loop counter stack J ( -- n ): copies enclosing loop’s counter stack K ( -- n ): copies enclosing loop’s enclosing loop’s counter stack BEGIN ( -- ): starts indefinite loop ( -- ): returns BEGIN ( flag -- ): flag, continue; else jump REPEAT REPEAT ( -- ): returns BEGIN following LEAVE ( -- ): leave current loop immediately","code":""},{"path":"http://www.ahl27.com/froth/articles/RInterface.html","id":"saving-and-loading","dir":"Articles","previous_headings":"","what":"Saving and Loading","title":"Interfacing with R","text":"quick detail important functions: functions saveFrothSession loadFrothSession allow save load froth environment, respectively. save variables words ’ve defined within froth. froth.RDefine words saved. froth.source identical froth.parse, except reads file rather character vector. writeFrothDictionary write defined words console (file specified) file. good utility exporting word definitions.","code":""},{"path":"http://www.ahl27.com/froth/articles/Variables.html","id":"variables","dir":"Articles","previous_headings":"","what":"Variables","title":"Variables, Constants, and Arrays","text":"Let’s say want store value somewhere outside stack. can initialize variable using VARIABLE word. Nothing happened! ’s word allocates space variable without actions. can now call name variable time push address onto stack. Forth, actual memory address. froth, however, uses abstracted memory map. can see address variable top stack. ’ll come back cell 0 bit later. store value variable, use !. can copy value address stick using @. Notice ! push value first, address. ’s also important note variable retains value even calling @. @ . pretty common call inspect value variable. fact, ’s common ’s shortcut word perform , ?. Variables often useful counters, using +! command. +! similar !, except adds variable rather replacing .","code":"fr> VARIABLE testvar ok. fr> test .s [[1]] [1] \"addr <test, cell 0>\"  [[2]] NULL  ok. fr> variable newvar ok. fr> 20 newvar ! ok. fr> newvar @ . 20 ok. fr> variable newvar ok. fr> 20 newvar ! ok. fr> newvar dup @ . dup @ . @ . 20 20 20 ok. fr> variable newvar 20 newvar ! ok. fr> newvar ? 20 ok. fr> variable newvar  ok. fr> 0 newvar ! ok. fr> 5 0 do 1 newvar +! loop newvar ? 5 ok."},{"path":"http://www.ahl27.com/froth/articles/Variables.html","id":"constants","dir":"Articles","previous_headings":"","what":"Constants","title":"Variables, Constants, and Arrays","text":"Sometimes just need name value. Variables never change values called constants, can fittingly defined CONSTANT word. Constants avoid hassle dealing addresses, can accessed slightly faster variables. Calling name variable copies value directly onto stack.","code":"fr> 100 CONSTANT hundred ok. fr> hundred . 100 ok."},{"path":"http://www.ahl27.com/froth/articles/Variables.html","id":"arrays","dir":"Articles","previous_headings":"","what":"Arrays","title":"Variables, Constants, and Arrays","text":"Remember said ’d come back whole “cell 0” thing? default, initializing variable creates space one “thing” address. Unlike Forth, froth creates space abstracted memory location, space big enough arbitrary R object. However, sometimes ’s nice variable can store one value, like case vectors lists R. Let’s start initializing array. definition proceeds like normal variables, just specify want variable larger single value: initializes variable 5 slots things. Internally, length 5 list. word ALLOT allots memory preceding variable, ’ll come back CELLS moment. Previously, saw behavior: cell 0 means address pointing first value array myarray. Cells 0-indexed froth, first entry array. Now , can store value first cell. ’m assuming address still stack, remember need call swap ensure top value address. Ok, now can look word CELLS. Let’s start inspecting get pushing CELLS stack: ’s fourth cell …nothing? CELLS creates unique kind address–stores cell number, doesn’t point variable. Words like ALLOT expect one objects tell much space allocate. CELLS calls don’t point anything, can add variable addresses get values array. Notice ’ve now gotten address myarray ’s offset 4 cells. Since size myarray 5, final entry array (indexing starts 0, 5 entries 0-4). address works like examples Variables section, can use !, @, +!, ? : ’re putting together. See can guess contents myarray now look like reading next section. start initializing array myarray size 5. , put 0 stack begin loop. iteration loop : 1. Dup top stack check less 5; , go (8) 2. Dup top stack twice. 3. Load address myarray, swap top duplicate 4. Create cell offset equal top duplicate, add address myarray 5. Store second duplicate (2) offset location 6. Add 1 value stack 7. loop 8. finish loop happens? stack 0, store 0 0th position myarray, 1 1st position, 2 second, etc. Let’s print entire array: ’s also possible initialize array specific value using CREATE , words. Pay close attention syntax! notice used ,? Unlike English, , froth word, meaning needs space separated acts upon stack. means must include command last element ensure ’s added array.","code":"fr> VARIABLE myarray 5 CELLS ALLOT ok. fr> myarray .s [[1]] [1] \"addr <myarray, cell 0>\"  [[2]] NULL  ok. fr> 1 swap ! ok. fr> myarray ? 1 ok. fr> 4 CELLS .s clear [[1]] [1] \"addr <, cell 4>\"  [[2]] NULL  ok. fr> myarray ok. fr> 4 CELLS + .s [[1]] [1] \"addr <myarray, cell 4>\"  [[2]] NULL  ok. fr> VARIABLE myarray 5 CELLS ALLOT ok. fr> 0 BEGIN dup 5 < WHILE dup dup myarray swap CELLS + ! 1 + REPEAT drop ok. fr> 5 0 do myarray i cells + ? loop 0 1 2 3 4 ok. fr> CREATE myarray 0 , 1 , 2 , 3 , 4 , ok. fr> 5 0 do myarray i cells + ? loop 0 1 2 3 4 ok."},{"path":"http://www.ahl27.com/froth/articles/Variables.html","id":"modifying-arrays","dir":"Articles","previous_headings":"","what":"Modifying Arrays","title":"Variables, Constants, and Arrays","text":"’s often useful able quickly change values size allocated arrays. change values array, can use FILL word. FILL expects three items stack: variable address, CELLS offset n, value x. fills first n cells x. ’s also shortcut word ERASE, equivalent 0 FILL. changes values, end wrong size array altogether? , two options: EXTEND REALLOT. words form; expect stack comprised variable address v value n. EXTEND make array v larger n cells, REALLOT change v exactly n cells (copying contents first n cells, ). ’re ever unsure large array , use LENGTH word copy length address stack, LENGTH? print .","code":"fr> variable filltest 3 cells allot ok. fr> 3 0 do i filltest i cells + ! loop ok. fr> 3 0 do filltest i cells + ? loop 0 1 2 ok. fr> filltest 3 cells 10 fill ok. fr> 3 0 do filltest i cells + ? loop 10 10 10 ok. fr> filltest 3 cells erase ok. fr> 3 0 do filltest i cells + ? loop 0 0 0 ok. fr> variable myarray 3 cells allot ok. fr> myarray 5 cells + ? Error: array accessed out of bounds! fr> myarray 2 cells extend ok. fr> myarray 5 cells + ? 0 ok. fr> 10 myarray 1 cells + ! ok. fr> myarray 3 cells reallot ok. fr> myarray 5 cells + ? Error: array accessed out of bounds! fr> myarray 1 cells + ? 10 ok. fr> variable myarray 10 cells allot ok. fr> myarray LENGTH . 10 ok. fr> myarray 20 cells reallot ok. fr> myarray LENGTH? 20 ok."},{"path":"http://www.ahl27.com/froth/articles/Variables.html","id":"words-in-this-chapter","dir":"Articles","previous_headings":"","what":"Words in this chapter","title":"Variables, Constants, and Arrays","text":"VARIABLE xxx: creates variable named xxx ! ( n addr -- ): stores value n address addr @ ( addr -- n ): copies value addr stack ? ( addr -- ): prints value addr +! ( n addr -- ): adds value n value addr CONSTANT xxx (n -- ): creates constant called xxx stores n; xxx returns n called ALLOT ( addr ncells -- ): allocates ncells cells addr CREATE xxx y1 , y2 , ... yn ,: creates array xxx values y1, y2, ... yn CELLS ( n -- ): creates memory address offset arrays FILL ( addr ncells val -- ): fills ncells cells memory beginning addr val ERASE ( addr ncells -- ): fills ncells cells memory beginning addr 0 REALLOT ( addr ncells -- ): reallots array addr size ncells. EXTEND ( addr ncells -- ): extends array addr ncells cells LENGTH ( addr -- len ): pushes length array addr onto stack LENGTH? ( addr -- ): prints length array addr","code":""},{"path":"http://www.ahl27.com/froth/articles/froth.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"froth","text":"Forth pretty darn cool language. Despite older C, Forth high level, typeless, stack-oriented programming language doubles extremely lighweight operating system. Think BASIC, …cooler. beauty Forth simplicity. system comprised single data stack dictionary, essentially linked list containing definitions called “words”. word links executable code. user enters text, interpreter traverses dictionary entered word executes corresponding code. Forth’s stack-oriented design means usage variables limited. froth brings Forth-like system R. can drop command-line editor, call Forth operations R. Since froth runs top R, supports R’s data structures. froth fast modern implementations Forth, package intended fun way play Forth-style syntax replacement existing Forths. However, stack-oriented algorthms advantages, may find R code benefit froth! included vignettes detail crash course froth-style Forth, using many examples based excellent guide forth.com. find bugs suggestions additional features, feel free let know GitHub!","code":""},{"path":"http://www.ahl27.com/froth/articles/froth.html","id":"differences-from-forth","dir":"Articles","previous_headings":"Introduction","what":"Differences from Forth","title":"froth","text":"section intended people experienced Forth, ’re just learn use froth, feel free skip ahead. expert Forth, especially given people programming Forth longer alive. may mistakes ’ve made implementation unintentional–find difference Forth haven’t mentioned, feel free leave comment GitHub. However, known differences implemented intentionally: - Sizes abstracted. numbers use R’s internals, integers implicitly convert reals division won’t -/underflow. Arrays use R’s list structure, cell can hold arbitrary amounts stuff. also means byte arrays supported. - Everything interpreted. Loops can executed outside definition. - Virtual memory. Users don’t get access system-level memory, mostly R doesn’t allow either. - Arbitrary R objects can pushed onto stack - haven’t yet implemented FORGET, ', /O froth. Words/variables can redefined time, ’ll destructively overwrite previous definition.","code":""},{"path":"http://www.ahl27.com/froth/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aidan Lakshman. Author, maintainer.","code":""},{"path":"http://www.ahl27.com/froth/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lakshman (2023). froth: Emulate 'Forth' Programming Environment. R package version 1.0.0, https://www.ahl27.com/froth/.","code":"@Manual{,   title = {froth: Emulate a 'Forth' Programming Environment},   author = {Aidan Lakshman},   year = {2023},   note = {R package version 1.0.0},   url = {https://www.ahl27.com/froth/}, }"},{"path":"http://www.ahl27.com/froth/index.html","id":"froth-forth-for-r","dir":"","previous_headings":"","what":"froth: Forth for R","title":"froth: Forth for R","text":"froth FORTH implementation R. ’re new froth Forth, check detailed overview -depth tutorial. implementation comes number differences FORTHs: - uses R operators arithmetic, 3 2 / returns 1.5 - arbitrary R objects can pushed onto stack - built-R print methods; use .R format according print method top parameter stack - obfuscated memory (direct emulated hardware-level memory access) - distinction compiled interpreted words (loops possible outside definitions!) - Use R lists internal arrays; arrays bytes supported (likely) 1:1 copy Gforth, think ’d rather forth implementation robust works R one exacly imitates existing Gforth. …tbd.","code":""},{"path":"http://www.ahl27.com/froth/index.html","id":"todos","dir":"","previous_headings":"","what":"TODOs","title":"froth: Forth for R","text":"' word kind /O functionality (though can read files froth R)","code":""},{"path":"http://www.ahl27.com/froth/reference/RInterface.html","id":null,"dir":"Reference","previous_headings":"","what":"Interface with froth from R — froth-RInterface","title":"Interface with froth from R — froth-RInterface","text":"Methods communicate froth environment without dropping REPL.","code":""},{"path":"http://www.ahl27.com/froth/reference/RInterface.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interface with froth from R — froth-RInterface","text":"","code":"froth.RPush(object) froth.RPop(nobj=1L) froth.RDefine(name, fun, nargs)"},{"path":"http://www.ahl27.com/froth/reference/RInterface.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interface with froth from R — froth-RInterface","text":"object R object push froth stack nobj Number objects pop froth stack name Froth name fun; see Examples fun R function define within froth nargs Number arguments expected fun","code":""},{"path":"http://www.ahl27.com/froth/reference/RInterface.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interface with froth from R — froth-RInterface","text":"functions allow interaction froth stack R. froth.RPush froth.RPop allow push/pop operations froth stack. operations called R, pushing R object supported. functions easier define using R froth. froth.RDefine creates froth function wrapper call specified R function, builds froth environment. makes using functions like rnorm within froth easier; see illustrative example. Functions defined froth.RDefine expect arguments popped directly froth stack, top stack corresponding last argument function.","code":""},{"path":"http://www.ahl27.com/froth/reference/RInterface.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interface with froth from R — froth-RInterface","text":"froth.RPop returns list top nobj elements stack. froth.RPush froth.RDefine invisibly return integer corresponding status operation. 0 indicates normal completion.","code":""},{"path":"http://www.ahl27.com/froth/reference/RInterface.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Interface with froth from R — froth-RInterface","text":"Aidan Lakshman ahl27@pitt.edu","code":""},{"path":"http://www.ahl27.com/froth/reference/RInterface.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Interface with froth from R — froth-RInterface","text":"Functions defined froth.RDefine saved using saveFrothSession.","code":""},{"path":"http://www.ahl27.com/froth/reference/RInterface.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interface with froth from R — froth-RInterface","text":"","code":"## Example of calling rnorm in froth  ## rnorm expects 3 arguments: rnorm(n, mean, sd) froth.RDefine(name='R_rnorm', fun=rnorm, nargs=3L)  ## Now we can call rnorm from froth using the 'R_rnorm' word. ## Note that the arguments are expected on the stack ## such that the top of the stack is `sd`, ## the second is `mean`, and the third is `n`.  ## n froth.RPush(5)  ## mean froth.RPush(0.0)  ## sd froth.RPush(1.0)  ## running the function ## note this will push the results back onto the stack froth.parse(\"R_rnorm\")  ## we can get the result with froth.RPop froth.RPop(5L) #> [[1]] #> [1] -0.2357756 #>  #> [[2]] #> [1] 0.1813963 #>  #> [[3]] #> [1] -0.4884646 #>  #> [[4]] #> [1] 1.129278 #>  #> [[5]] #> [1] 0.00731126 #>   ## As a oneliner: (doesn't return the values) froth.parse(\"5 0 1 R_rnorm .s\") #> [[1]] #> [1] 0.08501009 #>  #> [[2]] #> [1] 0.4048166 #>  #> [[3]] #> [1] -0.7226713 #>  #> [[4]] #> [1] -1.558129 #>  #> [[5]] #> [1] 0.7930508 #>  #> [[6]] #> NULL #>"},{"path":"http://www.ahl27.com/froth/reference/froth-dictionary.html","id":null,"dir":"Reference","previous_headings":"","what":"List/Export Installed froth Words — froth-dictionary","title":"List/Export Installed froth Words — froth-dictionary","text":"Functions inspect save installed froth words.","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-dictionary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List/Export Installed froth Words — froth-dictionary","text":"","code":"froth.dictionary() writeFrothDictionary(file=\"\", ...)"},{"path":"http://www.ahl27.com/froth/reference/froth-dictionary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List/Export Installed froth Words — froth-dictionary","text":"file file write , \"\" console ... additional arguments passed cat","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-dictionary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List/Export Installed froth Words — froth-dictionary","text":"froth.dictionary list installed words, grouped type (built-, alias, user-defined). writeFrothDictionary allows users export function definitions. default argument print user-defined definitions console. output can redirected file changing file argument.","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-dictionary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List/Export Installed froth Words — froth-dictionary","text":"None. froth.dictionary lists installed words using message, writeFrothDictionary either prints console file.","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-dictionary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"List/Export Installed froth Words — froth-dictionary","text":"Aidan Lakshman ahl27@pitt.edu","code":""},{"path":[]},{"path":"http://www.ahl27.com/froth/reference/froth-dictionary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List/Export Installed froth Words — froth-dictionary","text":"","code":"## Show all words froth.dictionary() #> Built-in Words: #> exit inspect words apply multiapply : forget lit #> ( noop abort\" reset clear swap 2swap dup #> 2dup dig over 2over 2drop rot drop ?dup #> >r r> r@ . .R emit .\" spaces #> space cr u.r + sum - * div #> idiv ^ mod /mod 1+ 1- 2+ 2- #> 2* 2/ negate abs min max sqrt */ #> */mod invert or and xor 0= 0< 0> #> < <= > >= = <> if else #> do begin loop +loop while leave until repeat #> i j k loopcounter loopend variable ! @ #> length length? +! ? constant cells allot extend #> reallot fill erase create , r_rnorm #>  #> Aliases: #> quit (exit) compile (:) ) (noop) .s (inspect) #> xx (reset) \\ (noop) % (mod) / (div) #> %/% (idiv) pow (^) times (*) ++ (1+) #> -- (1-) neg (negate) not (invert) ~ (invert) #> & (and) | (or) equal (=) eq (=) #> != (<>) neq (<>) gr (<) lt (>) #> geq (<=) leq (>=) then (noop) again (repeat) #>  #> User Definitions: #>   ## Define a few new words froth.parse(\": MAKE_THREE 1 2 + . ;\") froth.parse(\": MAKE_FIVE 2 3 + . ;\")  ## print out definition writeFrothDictionary() #> : MAKE_THREE 1 2 + . ; #> : MAKE_FIVE 2 3 + . ;"},{"path":"http://www.ahl27.com/froth/reference/froth-package.html","id":null,"dir":"Reference","previous_headings":"","what":"froth — froth-package","title":"froth — froth-package","text":"froth Forth implementation runs top R. allows users enjoy fun stack-oriented program within comfort R. can start REPL running froth() terminal. Future additions add ability execute forth scripts. Running top R provides key differences relative FORTH implementations: Data can contain arbitrary R objects. Froth searches dictionary, user-defined words, variables, R session variables deciding handle input word. R handling objects. means numerical inputs inherently identical R numbers. need double-size values, division operators use R methods default (3 2 / return 1.5, 1) Interpreted loops, meaning loops supported inside outside definitions. direct memory access. Support saving arbitrary R objects variable arrays. Support R print methods using .R word.","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-package.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"froth — froth-package","text":"","code":"## Start a froth REPL froth()"},{"path":"http://www.ahl27.com/froth/reference/froth-package.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"froth — froth-package","text":"None; operations within REPL modify internal froth stack.","code":""},{"path":[]},{"path":"http://www.ahl27.com/froth/reference/froth-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"froth — froth-package","text":"Maintainer: Aidan Lakshman ahl27@pitt.edu","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-parse-source.html","id":null,"dir":"Reference","previous_headings":"","what":"Read/evaluate froth code from R — froth-parse-source","title":"Read/evaluate froth code from R — froth-parse-source","text":"Function run froth code R.","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-parse-source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read/evaluate froth code from R — froth-parse-source","text":"","code":"froth.parse(inputline) froth.source(filepath)"},{"path":"http://www.ahl27.com/froth/reference/froth-parse-source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read/evaluate froth code from R — froth-parse-source","text":"inputline string parse froth filepath Path file containing froth FORTH code parse froth","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-parse-source.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read/evaluate froth code from R — froth-parse-source","text":"functions run froth interpreter strings read either arguments (froth.parse) file (froth.source). functions run froth code without enter REPL.","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-parse-source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read/evaluate froth code from R — froth-parse-source","text":"Invisibly returns integer status code, 0 corresponding normal execution.","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-parse-source.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read/evaluate froth code from R — froth-parse-source","text":"Aidan Lakshman ahl27@pitt.edu","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-parse-source.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read/evaluate froth code from R — froth-parse-source","text":"","code":"## Add two numbers froth.parse(\"1 2 + .\") #> 3   ## source a function to print a ASCII table called 'rect' tf <- tempfile() defn <- ': RECT 256 0 DO I 16 MOD 0= IF CR THEN .\" * \" LOOP ;' writeLines(defn, con=tf) froth.source(tf) froth.parse('rect') #>  #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   #> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *"},{"path":"http://www.ahl27.com/froth/reference/froth-reset.html","id":null,"dir":"Reference","previous_headings":"","what":"Reset the froth session — froth-reset","title":"Reset the froth session — froth-reset","text":"Resets froth session defaults. deletes user-defined functions variables, clears stack.","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-reset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reset the froth session — froth-reset","text":"","code":"froth.reset()"},{"path":"http://www.ahl27.com/froth/reference/froth-reset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reset the froth session — froth-reset","text":"None; called reset internal froth stacks.","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-reset.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Reset the froth session — froth-reset","text":"Aidan Lakshman ahl27@pitt.edu","code":""},{"path":"http://www.ahl27.com/froth/reference/froth-reset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reset the froth session — froth-reset","text":"","code":"froth.RDefine(\"rnorm\", rnorm, 3L) froth.reset() #> NULL froth.parse(\"5 0 1 rnorm .s\") #> [[1]] #> function (n, mean = 0, sd = 1)  #> .Call(C_rnorm, n, mean, sd) #> <bytecode: 0x55ceb8817fb8> #> <environment: namespace:stats> #>  #> [[2]] #> [1] 1 #>  #> [[3]] #> [1] 0 #>  #> [[4]] #> [1] 5 #>  #> [[5]] #> NULL #>  # fr> rnorm ?"},{"path":"http://www.ahl27.com/froth/reference/save-load-froth.html","id":null,"dir":"Reference","previous_headings":"","what":"Save/Load froth Sessions — save-load-froth","title":"Save/Load froth Sessions — save-load-froth","text":"Methods preserve user-defined entries variables.","code":""},{"path":"http://www.ahl27.com/froth/reference/save-load-froth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save/Load froth Sessions — save-load-froth","text":"","code":"saveFrothSession(file=NULL, ...) loadFrothSession(file=NULL)"},{"path":"http://www.ahl27.com/froth/reference/save-load-froth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save/Load froth Sessions — save-load-froth","text":"file Path file used saving/loading ... Additional arguments passed saveRDS","code":""},{"path":"http://www.ahl27.com/froth/reference/save-load-froth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Save/Load froth Sessions — save-load-froth","text":"saveFrothSession saves current user-defined methods variables within Froth dictionary file specified. Built-methods loaded package attached, saved. Note methods defined using froth.RDefine currently able saved. loadFrothSession restart froth environment, erase current user-defined methods variables. loads contents file specified current Froth session.","code":""},{"path":"http://www.ahl27.com/froth/reference/save-load-froth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save/Load froth Sessions — save-load-froth","text":"None. loadFrothSession update internal froth stacks, saveFrothSession save file.","code":""},{"path":"http://www.ahl27.com/froth/reference/save-load-froth.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Save/Load froth Sessions — save-load-froth","text":"Aidan Lakshman ahl27@pitt.edu","code":""},{"path":"http://www.ahl27.com/froth/reference/save-load-froth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save/Load froth Sessions — save-load-froth","text":"","code":"tf <- tempfile()   froth.RDefine('rnorm', rnorm, 3L)   saveFrothSession(tf)   froth.reset() #> NULL   froth.parse(\"5 0 1 rnorm .s\") #> [[1]] #> function (n, mean = 0, sd = 1)  #> .Call(C_rnorm, n, mean, sd) #> <bytecode: 0x55ceb8817fb8> #> <environment: namespace:stats> #>  #> [[2]] #> [1] 1 #>  #> [[3]] #> [1] 0 #>  #> [[4]] #> [1] 5 #>  #> [[5]] #> NULL #>    # fr> rnorm ?    loadFrothSession(tf)   froth.parse(\"5 0 1 rnorm .s\") #> [[1]] #> function (n, mean = 0, sd = 1)  #> .Call(C_rnorm, n, mean, sd) #> <bytecode: 0x55ceb8817fb8> #> <environment: namespace:stats> #>  #> [[2]] #> [1] 1 #>  #> [[3]] #> [1] 0 #>  #> [[4]] #> [1] 5 #>  #> [[5]] #> function (n, mean = 0, sd = 1)  #> .Call(C_rnorm, n, mean, sd) #> <bytecode: 0x55ceb8817fb8> #> <environment: namespace:stats> #>  #> [[6]] #> [1] 1 #>  #> [[7]] #> [1] 0 #>  #> [[8]] #> [1] 5 #>  #> [[9]] #> NULL #>"},{"path":"http://www.ahl27.com/froth/news/index.html","id":"version-100","dir":"Changelog","previous_headings":"","what":"Version 1.0.0","title":"Version 1.0.0","text":"Initial Release","code":""}]
